##### 浏览器相关面试点

###### 1.

##### 浏览器缓存机制

缓存可以说是性能优化中**简单高效**的一种优化方式了，它可以**显著减少网络传输所带来的损耗**。

对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。

接下来的内容中我们将通过以下几个部分来探讨浏览器缓存机制：

- 缓存位置
- 缓存策略
- 实际场景应用缓存策略

##### 缓存位置

从缓存位置上来说分为四种，并且各自有**优先级**，当依次查找缓存且都没有命中的时候，才会去请求网络

1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache
5. 网络请求

##### 缓存策略

通常浏览器缓存策略分为两种：**强缓存**和**协商缓存**，并且缓存策略都是通过设置 HTTP Header 来实现的

###### 强缓存

强缓存可以通过设置两种 HTTP Header 实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200。

###### 协商缓存

如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：`Last-Modified` 和 `ETag` 。

##### 实际场景应用缓存策略

###### 频繁变动的资源

对于频繁变动的资源，首先需要使用 `Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 `ETag` 或者 `Last-Modified` 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

###### 代码文件

这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。

一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 `Cache-Control: max-age=31536000`，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。

##### 浏览器渲染原理

###### 浏览器接收到 HTML 文件并转换为 DOM 树

###### 将 CSS 文件转换为 CSSOM 树

###### 生成渲染树

当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。在这一过程中，不是简单的将两者合并就行了。渲染树只会包括**需要显示的节点**和这些节点的样式信息，如果某个节点是 `display: none` 的，那么就不会在渲染树中显示。

当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。对于这一部分的内容因为过于底层，还涉及到了硬件相关的知识，这里就不再继续展开内容了。

##### 为什么操作 DOM 慢

想必大家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？

因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。

##### 经典面试题：插入几万个 DOM，如何实现页面不卡顿？

对于这道题目来说，首先我们肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。大部分人应该可以想到通过 `requestAnimationFrame`的方式去循环的插入 DOM，其实还有种方式去解决这个问题：**虚拟滚动**（virtualized scroller）。

**这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。**

##### 什么情况阻塞渲染

首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件**大小**，并且**扁平层级，优化选择器**。

然后当浏览器在解析到 `script` 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 `script` 标签放在 `body` 标签底部的原因。

当然在当下，并不是说 `script` 标签必须放在底部，因为你可以给 `script` 标签添加 `defer` 或者 `async` 属性。

当 `script` 标签加上 `defer` 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 `script` 标签放在任意位置。

对于没有任何依赖的 JS 文件可以加上 `async` 属性，表示 JS 文件下载和解析不会阻塞渲染。

##### 重绘（Repaint）和回流（Reflow）

重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。

- 重绘是当节点需要更改外观而不会影响布局的，比如改变 `color` 就叫称为重绘
- 回流是布局或者几何属性需要改变就称为回流。

回流**必定**会发生重绘，重绘**不一定**会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

###### 2.

##### 浏览器为什么发送options请求

跨域请求中，options请求是浏览器自发起的preflight request(预检请求)，以检测实际请求是否可以被浏览器接受。

preflight request请求报文中有两个需要关注的首部字段：

（1）Access-Control-Request-Method:告知服务器实际请求所用的HTTP方法；

（2）Access-Control-Request-Headers:告知服务器实际请求所携带的自定义首部字段。

同时服务器也会添加origin header，告知服务器实际请求的客户端的地址。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。

服务器所返回的Access-Control-Allow-Methods首部字段将所有允许的请求方法告知客户端，返回将所有Access-Control-Request-Headers首部字段将所有允许的自定义首部字段告知客户端。此外，服务器端可返回Access-Control-Max-Age首部字段，允许浏览器在指定时间内，无需再发送预检请求，直接用本次结果即可。

在我们开发过程中出现的浏览器自发起的options请求就是上面的第二种情况。实际上，跨域请求中的“复杂请求”发出前会进行一次方法是options的preflight request。

我们会发现，在很多post,put,delete等请求之前，会有一次options请求。

根本原因就是，W3C规范这样要求了！在跨域请求中，分为简单请求（get和部分post，post时content-type属于application/x-www-form-urlencoded，multipart/form-data，text/plain中的一种）和复杂请求。而复杂请求发出之前，就会出现一次options请求。

什么是options请求呢？它是一种探测性的请求，通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。

在ajax中出现options请求，也是一种提前探测的情况，ajax跨域请求时，如果请求的是json，就属于复杂请求，因此需要提前发出一次options请求，用以检查请求是否是可靠安全的，如果options获得的回应是拒绝性质的，比如404\403\500等http状态，就会停止post、put等请求的发出。

虽然在下面的参考文献中有人提出可以取消options请求，但是实测后发现是不行的，jquery封装之后，更不能轻易取消。因此，靠javascript客户端取消options请求是不可能的，只能通过服务端对options请求做出正确的回应，这样才能保证options请求之后，post、put等请求可以被发出。但是，我们不能允许所有的options请求，而应该是有条件的，所以最好是通过一个特殊的机制，去验证客户端发出的options请求数据是否是符合服务端的条件的，如果不满足，返回403，则客户端会取消原有的post计划。

前台跨域post请求，由于CORS（cross origin resource share）规范的存在，浏览器会首先发送一次options嗅探，同时header带上origin，判断是否有跨域请求权限，服务器响应access control allow origin的值，供浏览器与origin匹配，如果匹配则正式发送post请求。

如果有服务器程序权限，设置，比如jsp中，设置header access control allow origin等于*，就可以得到跨域访问的目的。

##### 请问http请求header中referer和origin的区别?

origin主要是用来说明最初请求是从哪里发起的；
origin只用于Post请求，而Referer则用于所有类型的请求；
origin的方式比Referer更安全点吧。

##### origin,referer和host区别

1. Host
   描述请求将被发送的目的地，包括，且仅仅包括域名和端口号。
   在任何类型请求中，request都会包含此header信息。
2. Origin
   用来说明请求从哪里发起的，包括，且仅仅包括协议和域名。
   这个参数一般只存在于CORS跨域请求中，可以看到response有对应的header：Access-Control-Allow-Origin。
3. Referer
   告知服务器请求的原始资源的URI，其用于所有类型的请求，并且包括：协议+域名+查询参数（注意，不包含锚点信息）。

###### 3.

##### 1.作用域

   1）全局作用域

   2）局部作用域（函数作用域）

   3）块级作用域，需结合let、const使用

​      {

​      	let f = 50;

​          const g = 60;      

​       }

##### 2.存取方式

   1）栈    先进后出，后进先出   （羊肉串）

   2）堆    无序存取，根据引用直接获取

   3）队列  先进先出， 后进后出

##### 3.内存空间（存储位置）

1.栈内存（堆栈内存）                                        2.堆内存

存储基本数据类型                                                存储引用数据类型

按值访问                                                               按引用访问

存储的值大小固定                                                存储的值大小不定，可动态调整

系统自动分配空间                                                手动分配空间

系统自动释放空间                                                手动释放空间

主要用来执行程序                                                 主要用来存放对象

空间小，运行效率高                                             空间大，但是运行效率相对较低

先进后出，后进先出                                             无序存储，可以根据引用直接获取

###### 4.

##### 执行上下文

Execution Context 执行上下文  简称EC）：当前代码的执行环境 。分为：全局环境 、函数环境、eval环境。

函数环境：当函数被调用时，会进入这个环境

debugger;执行到这行代码时，停止执行

##### 函数环境:

1.创建阶段

​     （1）.创建变量对象(Variable Object)简称V0

​            1).初始化arguments对象 它的值为Arguments对象

​					注意：只有执行上下文为函数环境的时候，才会初始化这个arguments对象

​             2).查找当前上下文的形参 

​                    a.找所有的形参并在变量对象里创建一条key:value

​                    b.key为形参的名字，value为对应实参的值。如果没有实参value为undefined

​             3).查找当前上下文的函数声明function(){}

​                    a.找function声明的函数并在变量对象里创建一条key:value

​                    b.key为function后的名字，value为函数在内存里的地址

​                    c.如果有同名的key,后面会把前面的覆盖

​             4).查找当前上下文的变量声明（var）

​                    a.找var声明的变量并在变量对象里创建一条key:value

​                    b.key为变量名，value为undefined

​                    c.如果key已经存在，直接跳过（为了防止这个key为函数，那函数会被修改为undefined）

注意：这里为什么不去查不用var声明的变量呢，不用var声明的变量严格来讲不叫变量，而是全局对象身上的属性

​       （2）.建立作用域链

​        （3）.确定this指向

2.代码执行阶段（变量对象要变成活动对象）

​     1）变量赋值（找=）

##### 全局环境：

1.创建阶段

​	  1）初始化内置对象

​      2）查找函数声明 function(){}

​      3)查找var声明的变量

2.执行阶段

​    1）变量赋值(找=)



代码分析：

if(true){

  var a = 1;

  const b = 2;

  let c = 3;

}

//全局作用域，不找 const let 只找var

console.log(a)

console.log(b)// ReferenceError:b is not defined

console.log(c)// ReferenceError:c is not defined



function aa(){

  var a = 1;

  const b = 2;

  let c = 3;

}

//函数作用域，不调用函数时，不执行查找

console.log(a)// ReferenceError:a is not defined

console.log(b)// ReferenceError:b is not defined

console.log(c)// ReferenceError:c is not defined



function aa(){

  var a = 1;

  const b = 2;

  let c = 3;

  console.log(a)// 1

}

aa()

//函数作用域，调用后，执行创建阶段和执行阶段，执行完就销毁，所以外面访问不到，函数内可以访问到

console.log(a)// ReferenceError:a is not defined

console.log(b)// ReferenceError:b is not defined

console.log(c)// ReferenceError:c is not defined



##### 函数表达式、函数声明、变量重名

1.在定义后面使用，取变量的值，哪个变量靠后取哪个变量的值。如果变量没有值，会选择有值的变量，都没有才选择函数。

2.在定义前面使用，始终取函数声明的值。

console.log(k)//undefined
var k = 'aa';
var k;
console.log(k)//a

a(); // f a(){console.log(a)}
var a = 10;
function a(){
    console.log(a);
}
a();//TypeError:a is not a function 此时 a= 10 ,相当于 10()

###### 5.

##### F5和Ctrl+F5的区别

一个是刷新，一个是强制刷新

按F5有时候一些内容是不会被更新的，而Ctrl+F5则所有内容都会被更新

具体区别是：

F5通常只是刷新本地缓存；

Ctrl+F5可以把INTERNET临时文件夹的文件删除再重新从服务器下载，也就是彻底刷新页面了

##### 浏览器缓存如何控制？

###### 方案一：无缓存

**说明**：浏览器向服务器请求资源m.png, 然后服务器响应请求--找到对应的m.png后发送给浏览器。 之后，浏览器再次向服务器请求m.png， 服务器又发回了同样的一张图片....循环往复.....

**优点**：浏览器请求，服务器响应，思路清楚简单容易实现。　　　

**缺点**：每次都请求同样的资源时，服务器也在不断地响应，这是非常浪费带宽的。

###### 方案二：有缓存-无更新

**说明：**　同样，浏览器向服务器请求资源ｍ.png,然后服务器找到后发送给浏览器，这时浏览器把m.png保存在本地（缓存）**,** 这样以后每次再请求m.png时就不需要向服务器要了，直接从本地取就行了，但是下次这个m.png的内容换了呢？

**优点：** 节省带宽（显然的，后续直接从本地取资源即可）。      

**缺点：** 如果服务器上的m.png内容改变，我就不能得到改变后的资源了，而是始终拿到本地的资源。

###### 方案三：有缓存-有更新

 **说明：** 浏览器向服务器请求资源m.png，然后服务器找到后发送给服务器，同时还附带额外信息---过期时间，如Expires: Friday,26 Feb 2017 10:11:22GMT。  然后浏览器将图片和过期时间同时保存在本地。 

 浏览器第二次向服务器请求资源，这时它会先查看过期事件是否已经达到，如果在过期事件之内，就直接使用本地缓存（**状态304**）； 如果超出了这个过期时间，就重新向服务器发送请求，服务器再次发回最新资源和最新的过期时间， 浏览器再次保存...

**优点：**  一方面可以在过期时间之内就可以不再重新请求资源，节省了带宽；另一方面也不会像第二种方案一样，而是可以得到新资源。

 **缺点：** 在过期时间之后就要重新请求资源，但是如果资源内容没改变呢？ 这次拿回的资源不就浪费了带宽吗？除此之外，这种时间格式复杂，容易比对出错。

###### 方案四：有缓存-有更新-更新机制加强

**说明：** 刚才的更新机制是发送来过期时间，而现在服务器在发送资源给浏览器的时候不再发送具体的时间，而是发送一个Cache-Control,这里可以包含各种信息。如Cache-Control: max-age=300; 这种方式和上面方案类似， 只是时间过期使用数字，不容易出错。另外Cache-Control还可以是下面的一些值：  

- Public---表示服务器发送的资源可以被任何中间节点缓存，如 Server -> proxy1 -> proxy2 -> Browser，proxy1 和 proxy2也可以缓存资源，这样，下次请求时proxy2就可以返回资源。
- Private---表示服务器发送的资源不可以被任何中间节点缓存。**
  **
- no-cache---表示不使用Cache-Control的缓存控制方式（强缓存），而是使用Etag 或者 Last-Modified（协商缓存）字段来控制缓存。
- no-store---表示真正地不用缓存方式（每次都请求最新的资源），Etag和Last-Modified也不用。
- max-age---表示当前资源的有效时间（就是强制缓存，用于替代HTTP1.0的Expires的方案）。

　**优点 ：** 使用max-age更加容易比对，其他的几个值使得缓存机制更加强大。 

​     **缺点：**同方案三，有可能导致浪费带宽。

###### 方案五：有缓存-有更新-更新机制完美

**说明：**为了解决方案四在300s后请求资源时得到了并未更新的资源而导致浪费带宽的情况，我们在给浏览器返回m.png图片时，不仅需要附加 Cache-Control: max-age=300; 再发送一个ETag字段,如 Etag:W/"e-dafdajio54fdaadf/q5w"。然后浏览器将图片和两个附加信息都保存起来， 300s内请求资源时，就从本地取，300s后请求资源时就将之前拿到的ETag信息随着请求发出，服务器接受到请求后先比对得到的ETag和服务器处图片当前的ETag，如果相同，则表示图片内容没变，就发送消息（不包含图片，**304**）；如果ETag改变，就发送新的m.png并且再发送一个新的Etag给浏览器保存，那么这时的max-age应该也是同样需要更新的，如此循环往复......

与Etag功能类似的是Last-Modified/if-Modified-Since ，当资源过期时（max-age超时），发现资源具有Last-Modified声明（是浏览器接收到的资源最新被修改的时间），于是发送请求时带上If-Modified-Since（即刚才的Last-Modified的时间）,web服务器收到请求时，将If-Modeified-Since时间的资源与当前资源对比， 如果没变， 就响应**HTTP304**，让浏览器使用缓存， 如果不是，就发送新的资源。 

######  6.

##### 从 URL 输入到页面展现到底发生什么？

总体来说分为以下几个过程:

- DNS 解析:将域名解析成 IP 地址
- TCP 连接：TCP 三次握手
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析渲染页面
- 断开连接：TCP 四次挥手

##### **一、URL 到底是啥**

URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。比如 [http://www.w3school.com.cn/ht...](https://link.zhihu.com/?target=http%3A//www.w3school.com.cn/html/index.asp)，遵守以下的语法规则：

```js
scheme://host.domain:port/path/filename
```

各部分解释如下：

- scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。
- host - 定义域主机（http 的默认主机是 www）
- domain - 定义因特网**域名**，比如 [http://w3school.com.cn](https://link.zhihu.com/?target=http%3A//w3school.com.cn)
- port - 定义主机上的端口号（http 的默认端口号是 80）
- path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
- filename - 定义文档/资源的名称

##### **二、域名解析（DNS）**

在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。

浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。

##### **三、TCP 三次握手**

在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。

![preview](https://pic1.zhimg.com/v2-31f1cee61df551bbb0f81b4b9688f5d4_r.jpg)

###### **1. TCP 三次握手的过程如下：**

- **客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口**（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
- **服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息**（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）
- **客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”**（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）

###### **2. 为啥需要三次握手**

谢希仁著《计算机网络》中讲“三次握手”的目的是“**为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误**”。

##### **四、发送 HTTP 请求**

TCP 三次握手结束后，开始发送 HTTP 请求报文。

请求报文由请求行（request line）、请求头（header）、请求体三个部分组成,如下图所示：

![preview](https://pic4.zhimg.com/80/v2-0004258bd5cd7513f175c093a69b8777_hd.jpg)

##### **五、服务器处理请求并返回 HTTP 报文**

##### **六、浏览器解析渲染页面**

浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制

![preview](https://pic2.zhimg.com/v2-db363acb52bf35ec64bb9cf9251a7121_r.jpg)

浏览器解析渲染页面分为一下五个步骤：

- 根据 HTML 解析出 DOM 树
- 根据 CSS 解析生成 CSS 规则树
- 结合 DOM 树和 CSS 规则树，生成渲染树
- 根据渲染树计算每一个节点的信息
- 根据计算好的信息绘制页面

###### **1. 根据 HTML 解析 DOM 树**

- 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。
- 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。

###### **2. 根据 CSS 解析生成 CSS 规则树**

- 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。
- 浏览器在 CSS 规则树生成之前不会进行渲染。

###### **3. 结合 DOM 树和 CSS 规则树，生成渲染树**

- DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。
- 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。

###### **4. 根据渲染树计算每一个节点的信息（布局）**

- 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸
- 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。

###### **5. 根据计算好的信息绘制页面**

- 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。
- 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。
- 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。

##### **七、断开连接**

###### **当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手**。

![preview](https://pic4.zhimg.com/v2-341a990377d3a445c14ebd961269b3d3_r.jpg)

- **发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态**。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)
- **被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态**。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)
- **被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态**。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)
- **发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭**。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)

###### 7.

##### 监控

前端监控一般分为三种，分别为页面埋点、性能监控以及异常监控。

###### 页面埋点

页面埋点应该是大家最常写的监控了，一般起码会监控以下几个数据：

- PV / UV
- 停留时长
- 流量来源
- 用户交互

对于这几类统计，一般的实现思路大致可以分为两种，分别为手写埋点和无埋点的方式。

相信第一种方式也是大家最常用的方式，可以自主选择需要监控的数据然后在相应的地方写入代码。这种方式的灵活性很大，但是唯一的缺点就是工作量较大，每个需要监控的地方都得插入代码。

另一种无埋点的方式基本不需要开发者手写埋点了，而是统计所有的事件并且定时上报。这种方式虽然没有前一种方式繁琐了，但是因为统计的是所有事件，所以还需要后期过滤出需要的数据。

###### 性能监控

性能监控可以很好的帮助开发者了解在各种真实环境下，页面的性能情况是如何的。

对于性能监控来说，我们可以直接使用浏览器自带的 [Performance API](https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FPerformance) 来实现这个功能。

对于性能监控来说，其实我们只需要调用 `performance.getEntriesByType('navigation')` 这行代码就行了。对，你没看错，一行代码我们就可以获得页面中各种详细的性能相关信息。

###### 异常监控

对于异常监控来说，以下两种监控是必不可少的，分别是代码报错以及接口异常上报。

对于代码运行错误，通常的办法是使用 `window.onerror` 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外

- 对于跨域的代码运行错误会显示 `Script error.` 对于这种情况我们需要给 `script` 标签添加 `crossorigin` 属性
- 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 `arguments.callee.caller` 来做栈递归

对于异步代码来说，可以使用 `catch` 的方式捕获错误。比如 `Promise` 可以直接使用 `catch` 函数，`async await` 可以使用 `try catch`。

但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。

对于捕获的错误需要上传给服务器，通常可以通过 `img` 标签的 `src` 发起一个请求。

另外接口异常就相对来说简单了，可以列举出出错的状态码。一旦出现此类的状态码就可以立即上报出错。接口异常上报可以让开发人员迅速知道有哪些接口出现了大面积的报错，以便迅速修复问题。

##### Post 和 Get 的区别？

在技术上说：

- Get 请求能缓存，Post 不能
- Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里（当然你想写到 `body` 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。
- URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
- Post 支持更多的编码类型且不对数据类型限制

##### 常见状态码

**2XX 成功**

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
- 206 Partial Content，进行范围请求

**3XX 重定向**

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

**4XX 客户端错误**

- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

**5XX 服务器错误**

- 500 internal sever error，表示服务器端在执行请求时发生了错误

- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能

- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

  

HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的

QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议

##### 输入 URL 到页面渲染的整个流程

1）首先是 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来，这部分的内容之前没有写过，所以就在这里讲解下。

DNS

DNS 的作用就是通过域名查询到具体的 IP。

因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。

在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 `www.google.com` 时，会进行一下操作：

1. 操作系统会首先在本地缓存中查询 IP
2. 没有的话会去系统配置的 DNS 服务器中查询
3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 `com` 这个一级域名的服务器
4. 然后去该服务器查询 `google` 这个二级域名
5. 接下来三级域名的查询其实是我们配置的，你可以给 `www` 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP

以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。

PS：DNS 是基于 UDP 做的查询，大家也可以考虑下为什么之前不考虑使用 TCP 去实现。

2）接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。

在这一部分中，可以详细说下 TCP 的握手情况以及 TCP 的一些特性。

当 TCP 握手结束后就会进行 TLS 握手，然后就开始正式的传输数据。

在这一部分中，可以详细说下 TLS 的握手情况以及两种加密方式的内容。

3）

数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件。

首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。

浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script  标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML  解析完成后顺序执行。

如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。

CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西

在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。

##### 什么是HTTPS?

HTTPS = HTTP + SSL/TLS ，是HTTP协议的安全版。

##### SSL/TLS又是什么？

SSL的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL最新放入版本是3.0。

TLS的全称是Transport Layer Security，即安全传输层协议，是建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。

##### 为什么要用HTTPS？

因为HTTP在“裸奔”（明文传输，不安全）

##### HTTPS的作用

- 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全
- 对网站服务器进行真实身份认证

###### 8.

性能：

- 可以通过 **Audit** 工具获得网站的多个指标的性能报告
- 可以通过 **Performance** 工具了解网站的性能瓶颈
- 可以通过 **Performance** API 具体测量时间
- 为了减少编译时间，我们可以采用**减少代码文件的大小**或者**减少书写嵌套函数**的方式
- 为了让 V8 优化代码，我们应该尽可能保证传入参数的**类型一致**。这也给我们带来了一个思考，这是不是也是使用 TypeScript 能够带来的好处之一

##### 1.图片优化

###### 计算图片大小

​    1）减少像素点

​     2）减少每个像素点能够显示的颜色

  图片加载优化

1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
3. 小图使用 base64 格式
4. 将多个图标文件整合到一张图片中（雪碧图）
5. 选择正确的图片格式：
   - 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
   - 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   - 照片使用 JPEG



##### 2.DNS 预解析

DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。

```
<link rel="dns-prefetch" href="//yuchengkai.cn">
```

##### 3.节流

考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。

##### 4.防抖

考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。

##### 5.预加载

在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。

预加载其实是声明式的 `fetch` ，强制浏览器请求资源，并且不会阻塞 `onload` 事件，可以使用以下代码开启预加载

```
<link rel="preload" href="http://example.com">
```

预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。

##### 6.预渲染

可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```
<link rel="prerender" href="http://example.com"> 
```

预渲染虽然可以提高页面的加载速度，但是要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染。

##### 7.懒执行

懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。

##### 8.懒加载

懒加载就是将不关键的资源延后加载。

懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载。

懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。

##### 9.CDN

CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

#### Webpack 性能优化

- 有哪些方式可以减少 Webpack 的打包时间
- 有哪些方式可以让 Webpack 打出来的包更小

###### 减少 Webpack 打包时间

###### 1）优化 Loader

对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，**转换代码越多，效率就越低**。当然了，我们是有办法优化的。

首先我们可以**优化 Loader 的文件搜索范围**

当然这样做还不够，我们还可以将 Babel 编译过的文件**缓存**起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间

```
loader: 'babel-loader?cacheDirectory=true'
```

###### 2）HappyPack

受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。

**HappyPack 可以将 Loader 的同步执行转换为并行的**，这样就能充分利用系统资源来加快打包效率了

###### 3）DllPlugin

**DllPlugin 可以将特定的类库提前打包然后引入**。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。

###### 4）代码压缩

可以使用 `webpack-parallel-uglify-plugin` 来并行运行 `UglifyJS`，从而提高效率。

###### 减少 Webpack 打包后的文件体积

1）按需加载

2）Scope Hoisting

**Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。**

3）Tree Shaking

**Tree Shaking 可以实现删除项目中未被引用的代码**

###### 9.

axios 笔记

axios的文档...发现它传参有两种方式，一种是params，一种是data，

而params会默认把 要传的参数添加到url后面

1. params会将请求的参数拼接到url中去，用于get请求
2. data是添加到请求体(body)里面去，用于post请求



post请求可以使用params方式传值

![image.png](https://upload-images.jianshu.io/upload_images/13899355-7ef3fbbf846c10fd.png&originHeight=239&originWidth=425&size=10502&status=done&style=none&width=425?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`/create?name=***&age=****`,但是是一个`post`请求

解决方法：

axios签名是`axios.post(url[, data[, config]])`。所以你想在第三个参数中发送params对象

```
axios.post(`/create`, null, { params:{name,age}})
.then(response => response.status)
.catch(err => console.warn(err) );
```



axios中delete 多样传参

//请求参数放在请求体中

```
axios.delete(`/delete`, {data: {id: 12}})
.then(res => {console.log(res) })
```

//请求参数拼接在url上用params

```
axios.delete(`/delete`, {params: {id: 12}})
.then(res => {console.log(res) })
```



1、export default 向外暴露的成员，可以使用任意变量来接收

2、在一个模块中，export default 只允许向外暴露一次

3、在一个模块中，可以同时使用export default 和export 向外暴露成员

4、使用export向外暴露的成员，只能使用{ }的形式来接收，这种形式，叫做【按需导出】

5、export可以向外暴露多个成员，同时，如果某些成员，在import导入时，不需要，可以不在{ }中定义

6、使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收

7、使用export导出的成员，如果想换个变量名称接收，可以使用as来起别名

8、在一个文件或模块中，`export`、`import`可以有多个，`export default`仅有一个

9、通过 `export` 方式导出，在导入时要加`{ }`，`export default` 则不需要



![image-20201019094518954](C:\Users\Grace.Liu1\AppData\Roaming\Typora\typora-user-images\image-20201019094518954.png)

一般vue-router报错说明是路由配置出问题了，或者跳转路由的时候出现死循环，RangeError: Maximum call stack size exceeded 是死循环出现的语句。





some()方法用于检测数组中的元素是否满足指定条件（函数提供）。

some()方法会依次执行数组的每个元素：

如果有一个元素满足条件，则表达式返回true，剩余的元素不会再执行检测。如果没有满足条件的元素，则返回false。

some()不会对空数组进行检测。some()不会改变原始数组。

##### url传参

url出现了有+，空格，/，?，%,  #,  &,  =等特殊符号的时候，可能在服务器端无法获得正确的参数值，如何是好？

解决办法

将这些字符转化成服务器可以识别的字符，对应关系如下：

+URL中+号表示空格  %2B

空格 URL中的空格可以用+号或者编码 %20

/ 分隔目录和子目录  %2F

? 分隔实际的URL和参数 %3F

% 指定特殊字符              %25

#表示书签                        %23

&URL中指定的参数间的分隔符 %26

=URL中指定参数的值 %3D



关于一些url中传递参数有空格问题：

url.replace(/ /g, '%20');

从上面的例子中可以看到可以用：replace(/ /g, '%20')来替换url中参数的空格。url中的空格可以用+或者%20代替。



可以用js中的encodeURI(String)或encodeURIComponent(String)方法。

encodeURI: 对整个的url进行编码时使用。

encodeURIComponent:对某个url中的参数进行编码。

这个问题在使用加密工具加密参数后再传参时是很常见的，因为加密后的字符串里面经常带有加号+。

###### 10.

##### 

1.《JavaScript权威指南》中的概念：闭包是指有权访问另一个函数作用域中的变量的函数。

2.对于JavaScript而言，匿名函数是一个很重要且具有逻辑性的特性。通常，匿名函数的使用情况是：创建一个供以后使用的函数。

3.递归，说白了，就是自己调用自己

4.内部环境可以通过作用域链访问到外部环境的变量。反之不可。这些环境之间的联系都是线性、有次序的。

5.不变性要求不能改变原始对象。幸运的是，解构可以以不可变的方式轻松实现某些操作。

const numbers = [1, 2, 3];
const [, ...fooNumbers] = numbers;
fooNumbers; // => [2, 3]
numbers; // => [1, 2, 3]

解构 `[, ... fooNumbers] = numbers`创建一个新的数组`fooNumbers`，`fooNumbers` 包含 `numbers`元素，除了第一个元素。

`numbers` 数组没有发生变化，保持操作不变性。

解构左侧的逗号：它表示忽略第一个元素,

可以对任何实现[可迭代协议( iterable protocol)](https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FIteration_protocols%23The_iterable_protocol)的对象进行解构

许多原生基本类型和对象都是可迭代的: `array`, `string`, `typed arrays`, `set` 和 `map`。

6.当创建一个函数时，JS会自动为函数添加`prototype`属性，值是一个有`constructor`的对象。

7.for in是ES5标准，遍历key. 迭代所有可枚举的，除了 Symbol
for of是ES6标准，遍历value.

for in 更适合遍历对象，不要使用for in 遍历数组。

记住，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。

8.toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。

- `string + number` will transform number to string, outputs string
- `string - number` will transform string to number, outputs number

...浅拷贝

9.重要的是，知道 for...in、Object.keys(obj)、Object.getOwnPropertyNames(obj)、Object.getOwnPropertySymbols(obj)、Reflect.ownKeys(obj)，这 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则：

1. 首先遍历所有数值键，按照数值升序排列。
2. 其次遍历所有字符串键，按照加入时间升序排列。
3. 最后遍历所有 Symbol 键，按照加入时间升序排列。

10.('b'+'a'+ + 'a'+'a').toLowerCase() === 'banana'？

=>'b'+'a'+(+'a')+'a' =>'b'+'a'+(NaN)+'a' =>baNaNa toLowerCase() =>banana

11.感谢现代浏览器，现在不是所有打开的标签页都依赖于一个JavaScript线程。而是每个标签页或者域名都会有独立的JavaScript线程。这样每个标签页之间不会互相阻塞。比如你可以在Chrome中打开多个标签页，在某个标签页下执行上面的死循环，你会发现只有执行了上面语句的标签卡死，其他不受影响。

**构造/new调用函数的时候做了什么**：

1. 创建一个全新的对象。
2. 这个新对象的原型(`Object.getPrototypeOf(target)`)指向构造函数的`prototype`对象。
3. 该函数的this会绑定在新创建的对象上。
4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。
5. 我们称这个新对象为构造函数的实例。

**可以用以下三句话来理解原型链**：

1. **每个对象都拥有一个原型对象**: `newObj`的原型是`foo.prototype`。
2. **对象的原型可能也是继承其他原型对象的**: `foo.prototype`也有它的原型`Object.prototype`。
3. **一层一层的，以此类推，这种关系就是原型链**。

如果一个对象存在另一个对象的原型链上，我们可以说：它们是继承关系。

##### 原型链的终点: `Object.prototype`

`Object.prototype`是原型链的终点，所有对象都是从它继承了方法和属性。

**Object.prototype没有原型对象**

##### 原型链用来做什么？

###### 属性查找：如果试图访问对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性，以此类推

##### 一个对象是否在另一个对象的原型链上的判断方式？

1. `instanceof`: 用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置

语法：`object instanceof constructor`

​     2.isPrototypeOf：测试一个对象是否存在于另一个对象的原型链上

##### 语法：`prototypeObj.isPrototypeOf(object)`

`hasOwnProperty`: 指示对象自身属性中是否具有指定的属性

语法：`obj.hasOwnProperty(prop)`

参数: `prop` 要查找的属性

返回值: 用来判断某个对象是否含有指定的属性的`Boolean`。

##### 360安全浏览器“极速模式”和“兼容模式”的区别

###### **如何选择内核？**

​    360安全浏览器现有两种内核模式，即“极速模式”和“兼容模式”。

###### **极速模式**

​    “极速模式”是以Blink（Webkit）为内核的浏览模式，Blink内核具有更高的网页浏览速度和更好网页渲染效果。但由于少部分网银、政府、税务、办公系统等网站对Blink的兼容性不佳，若打开此类网站发现异常，请手动切换到“兼容模式”下继续浏览。

###### **兼容模式**

​    “兼容模式”下，360安全浏览器调用Trident内核（IE内核），Trident内核具有网页兼容性好、页面适用性广的特征，对于部分在默认“极速模式”下出现问题的网页（如：使用了Activex控件、页面代码只支持Trident内核、网页中注明使用IE浏览器）的情况下，切换“兼容模式”就可以正常使用网站功能。

1、极速模式使用的是Webkit内核，Webkit内核是全球最快速的浏览器内核，同时支持了诸多的网页新标准，但由于Webkit内核较新，国内一些网站尚未较好地支持此内核。

2、兼容模式使用的是IE浏览器所使用的 Trident 内核，是国内网页制作时主要兼容的浏览器内核，兼容性问题较少。

3、IE9/IE10模式使用的是IE9/IE10浏览器所使用的新内核，加入了硬件加速、全新的脚本渲染引擎，更标准的HMTL5及CSS3支持。

##### ES新提案：双问号操作符

双问号 `??` 的操作符跟 `||` 类似，如果给定变量值为 `null` 或者 `undefined`，使用双问号后的默认值，否则使用该变量值。

> undefined ?? 'default'
> 'default'
> null ?? 'default'
> 'default'
> false ?? 'default'
> false
> '' ?? 'default'
> ''
> 0 ?? 'default'
> 0

##### text-transform简单介绍

这是CSS2中的属性，参数有capitalize | uppercase | lowercase | none

none:默认。定义带有小写字母和大写字母的标准的文本。

capitalize:文本中的每个单词以大写字母开头。

uppercase:定义仅有大写字母。

lowercase:定义无大写字母，仅有小写字母。

##### 两个选择器的区别：

~ 选择器：查找某个元素后面的所有兄弟元素

+选择器：查找某个元素后面紧邻的兄弟元素

##### 多列等高问题： 使用display:table

##### 表单验证

HTML5关于<input>的新属性--pattern（检查控件值的正则表达式）

##### invalid伪类和valid伪类

valid伪类，匹配通过pattern验证的元素

invalid伪类，匹配未通过pattern验证的元素

##### ES5和ES6继承的区别？

ES6 与 ES5 中的继承有 2 个区别，第一个是，ES6 中子类会继承父类的属性，第二个区别是，super() 与 A.call(this) 是不同的，在继承原生构造函数的情况下，体现得很明显，ES6 中的子类实例可以继承原生构造函数实例的内部属性，而在 ES5 中做不到。

##### Array map()

##### JSON.stringify()

`**JSON.stringify()**` 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，如果指定了replacer是一个函数，则可以选择性的替换值，或者如果指定了replacer是一个数组，可选择性的仅包含数组指定的属性。

```
JSON.stringify(value[, replacer [, space]])
```

```
value
```

将要序列化成 一个JSON 字符串的值。

`replacer` 可选

如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化

`space` 可选

指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格。

- 转换值如果有toJSON()方法，该方法定义什么值将被序列化。

- 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。

- 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。

- ###### `undefined、`任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 `null`（出现在数组中时）。函数、undefined被单独转换时，会返回undefined，如`JSON.stringify(function(){})` or `JSON.stringify(undefined).`

- 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。

- 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 `replacer` 参数中强制指定包含了它们。

- Date日期调用了toJSON()将其转换为了string字符串（同Date.toISOString()），因此会被当做字符串处理。

- NaN和Infinity格式的数值及null都会被当做null。

- 其他类型的对象，包括Map/Set/weakMap/weakSet，仅会序列化可枚举的属性。

a = Array(3) //[empty * 3]

b = new Array(3) //[empty * 3]

c = Array.apply(null,{length:3}) // [undefined, undefined, undefined]

map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。

map() 方法按照原始数组元素顺序依次处理元素。

**注意：** map() 不会对空数组进行检测。map()不会改变原始数组。

语法：array.map(function(currentValue,index,arr), thisValue)

| 参数                                | 描述                                                         |
| :---------------------------------- | :----------------------------------------------------------- |
| *function(currentValue, index,arr)* | 必须。函数，数组中的每个元素都会执行这个函数                  函数参数: *currentValue*必须。当前元素的值                             index可选。当前元素的索引值                                                        *arr*可选。当前元素属于的数组对象 |
| *thisValue*                         | 可选。对象作为该执行回调时使用，传递给函数，用作 "this" 的值。 如果省略了 thisValue，或者传入 null、undefined，那么回调函数的 this 为全局对象。 |

  

let  a = 1;
var b = 2;
console.log(a, window.a, window.b); // 1 undefined   2

原因：let不是全局变量，var是全局变量

##### Remember the keywords:

- `for...in`: excluding `non-enumerable`, including `__proto__`
- `Object.getOwnPropertyNames` & `hasOwnProperty`: including `non-enumerable`, excluding `__proto__`
- `Object.keys` & `Object.assign` & `JSON.stringify`: excluding `non-enumerable` & `__proto__`
- `... in ...`: including `non-enumerable` & `__proto__`

obj = { a: 1 };
x = Object.create(obj); //创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 

- `x = Object.create(obj)` creates a new object, using the existing object `obj` as the prototype of the newly created object `x`.

```html
Object.create(proto[, propertiesObject])
```

```
proto
```

新创建对象的原型对象。

```
propertiesObject
```

可选。为新创建的对象指定属性对象。如果没有指定为 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应[`Object.defineProperties()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)的第二个参数。

该属性对象可能包含以下值：

| 属性         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| configurable | 表示新创建的对象是否是可配置的，即对象的属性是否可以被删除或修改，默认false |
| enumerable   | 对象属性是否可枚举的，即是否可以枚举，默认false              |
| writable     | 对象是否可写，是否或以为对象添加新属性，默认false            |
| get          | 对象getter函数，默认undefined                                |
| set          | 对象setter函数，默认undefined                                |

##### typeof

- typeof 对于基本类型，除了null都可以显示正确的类型  `typeof null` 结果是 `object`
- 想获得一个变量的正确类型，可以通过Object.prototype.toString.call(xx)

基本类型有6种：null 、undefined 、boolean 、number 、string 、symbol 

##### 斐波那契数列

**因为JavaScript是单线程的，所以它只有一个栈和堆**。

**所以说我们Javascript是单线程的，但是很多Web API的执行是多线程的。也就是说Javascript的单线程指的是‘Javascript代码’的执行是单线程**.

##### 块作用域：

当用 `let` 声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 `var` 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 `for` 循环之外是不能访问的。

拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。

##### 箭头函数

- this指向定义时的环境。
- 不可new实例化
- this不可变
- 没有arguments对象

对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 [自身的可枚举属性](https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FEnumerability_and_ownership_of_properties)。 大体上是说当你展开一个对象实例时，你会丢失其方法

在参数传递方式上，**值类型**是按值传递，**引用类型**是按共享 传递。

##### 总结：

- 所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（null除外）
- 所有的引用类型（数组、对象、函数），都有一个__ proto __属性，属性值是一个普通的对象
- 所有的函数，都有一个prototype属性，属性值也是一个普通的对象
- 所有的引用类型（数组、对象、函数），__ proto __ 属性值指向它的构造函数的prototype属性值

hasOwnProperty ： 判断这个属性是不是对象本身的属性

一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回undefined。最上层是什么---Object.prototype.__ proto __ === null 。原型链并不是无限的，原型链最终指向null 。

##### 作用域

作用域就是一个独立的地盘，让变量不会外泄、暴露出去。

变量的作用域有2种：全局变量和局部变量

全局作用域：最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的。

局部作用域：局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的。最常见的例如函数内部

##### 闭包主要有两个应用场景：

- 函数作为返回值
- 函数作为参数传递

匿名函数具有全局性，因此this对象指向window。

##### 前端异步的场景描述

- 定时任务：setTimeout setInterval
- 绑定事件：addEventListener(click等等)
- 网络请求：ajax和img动态加载

解构赋值：解构不成功，变量的值就等于undefined。解构赋值允许指定默认值。

箭头函数中的this指向的是定义时的this，而不是执行时的this。

##### Cookie

Cookie是一小段文本信息，伴随着用户请求和页面在web服务器和浏览器之间传递。用户每次访问站点时，web应用程序都可以读取Cookie包含的信息。

Cookie的出现是为了解决保存用户信息的问题。

###### Cookie缺点：

`cookie`可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；

`cookie`是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的`cookie`也是不能互相访问的；

`cookie`可能被删除。因为每个`cookie`都是硬盘上的一个文件，因此很有可能被用户删除；

`cookie`安全性不够高。所有的`cookie`都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。

###### Cookie工作方式

服务器以cookie的形式向访问者的浏览器发送一些数据。如果浏览器允许接受cookie，则将其作为纯文本记录记录存储在访问者的硬盘上。

![img](https://user-gold-cdn.xitu.io/2019/9/3/16cf47967fe0d499?imageslim)

GC(Garbage Collection)垃圾回收

##### 不是数组怎么reduce

1）普通对象：使用Object.keys,Object.values,Object.entries再reduce

2）类数组对象：使用[...o]

3）字符串: [].reduce.call(string, (res, cur) => {}, result)

4）假数组: 如{ 0: 'a', 1: 'b', length: 2 }，使用Array.from(o)、Array.apply(null, o)

5）有symbol做key的对象:使用getOwnPropertySymbols

###### JavaScript 多态

在面向对象语言中，接口的多种不同的实现方式即为多态。多态的优点：扩展性强、消除类型之间的耦合关系、接口性、可替换性

存在的三个必要条件：继承、重写、父类引用指向子类对象

###### javascript 封装

封装的表现形式，所解决的问题是，私有变量，不让外部访问到

###### 函数声明和类声明之间的一个重要区别就是函数声明会提升， 类声明不会。

ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面Parent.apply(this)

ES6的继承则是，将父类实例对象的属性和方法，加到this上面（所以必须先调用super()）,然后在用子类的构造函数修改this。内部的this指向的是child。



